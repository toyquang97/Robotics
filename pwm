/* USER CODE BEGIN PTD */
#define PWMfreq 50000
#define max_duty 100	
#define duty_default 50 // duty = 50% PTO with high F
#define stop_duty 0
/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/

/* USER CODE BEGIN PV */


uint8_t tx_buff[]={"robotics adt"};
uint8_t RecvBuffer[8];
int32_t pulse_width[6]={-20000,-40000,-30000,-5000,-500,-1000};
uint32_t cnt =0;
uint16_t status[6];
GPIO_PinState bt;


/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
/* USER CODE BEGIN PFP */
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart);
void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart);
void PWM_out(uint32_t freq, int16_t duty, TIM_HandleTypeDef *htim, uint32_t Channel,int32_t numberOfPulse[6]);
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim);
void ControlServo(void);


void PWM_out(uint32_t freq, int16_t duty, TIM_HandleTypeDef *htim, uint32_t Channel, int32_t numberOfPulse[6]){		
	int i = 0;
	for ( i = 0; i < 6; i++ )
	{	
		pulse_width[i] = numberOfPulse[i];
	}	
	/// set direc for motor
	if(numberOfPulse[0] < 0){
				HAL_GPIO_WritePin(SIGN0_GPIO_Port, SIGN0_Pin, GPIO_PIN_SET); // dir = 1
	}
	else if(numberOfPulse[0] > 0)	{
				HAL_GPIO_WritePin(SIGN0_GPIO_Port, SIGN0_Pin, GPIO_PIN_RESET); // dir = 0
	}
	else if(numberOfPulse[1] > 0)	{
				HAL_GPIO_WritePin(SIGN0_GPIO_Port, SIGN0_Pin, GPIO_PIN_SET); // dir = 1
	}
	else if(numberOfPulse[1] < 0)	{
				HAL_GPIO_WritePin(SIGN0_GPIO_Port, SIGN0_Pin, GPIO_PIN_RESET); // dir = 0
	}
	else if(numberOfPulse[2] > 0)	{
				HAL_GPIO_WritePin(SIGN0_GPIO_Port, SIGN0_Pin, GPIO_PIN_SET); // dir = 1
	}
	else if(numberOfPulse[2] < 0)	{
				HAL_GPIO_WritePin(SIGN0_GPIO_Port, SIGN0_Pin, GPIO_PIN_RESET); // dir = 0
	}
	else if(numberOfPulse[3] > 0)	{
				HAL_GPIO_WritePin(SIGN0_GPIO_Port, SIGN0_Pin, GPIO_PIN_SET); // dir = 1
	}
	else if(numberOfPulse[3] < 0)	{
				HAL_GPIO_WritePin(SIGN0_GPIO_Port, SIGN0_Pin, GPIO_PIN_RESET); // dir = 0
	}
	else if(numberOfPulse[4] > 0)	{
				HAL_GPIO_WritePin(SIGN0_GPIO_Port, SIGN0_Pin, GPIO_PIN_SET); // dir = 1
	}
	else if(numberOfPulse[4] < 0)	{
				HAL_GPIO_WritePin(SIGN0_GPIO_Port, SIGN0_Pin, GPIO_PIN_RESET); // dir = 0
	}
	else if(numberOfPulse[5] > 0)	{
				HAL_GPIO_WritePin(SIGN0_GPIO_Port, SIGN0_Pin, GPIO_PIN_SET); // dir = 1
	}
	else if(numberOfPulse[5] < 0)	{
				HAL_GPIO_WritePin(SIGN0_GPIO_Port, SIGN0_Pin, GPIO_PIN_RESET); // dir = 0
	}
	
	
	// set pulse always poisitive 
	for ( int i = 0; i < 6; i++ )
	{	
			if (pulse_width[i] < 0)		pulse_width[i]=-pulse_width[i];
			else if (pulse_width[i] > 0) 	pulse_width[i]= pulse_width[i];
	}
	
	// check direc
	status[0] = HAL_GPIO_ReadPin(SIGN0_GPIO_Port,SIGN0_Pin);
	status[1] = HAL_GPIO_ReadPin(SIGN0_GPIO_Port,SIGN0_Pin);
	status[2] = HAL_GPIO_ReadPin(SIGN0_GPIO_Port,SIGN0_Pin);
	status[3] = HAL_GPIO_ReadPin(SIGN0_GPIO_Port,SIGN0_Pin);
	status[4] = HAL_GPIO_ReadPin(SIGN0_GPIO_Port,SIGN0_Pin);
	status[5] = HAL_GPIO_ReadPin(SIGN0_GPIO_Port,SIGN0_Pin);
	
/// setup register for motor
	uint32_t period;
	period = 84000000/(freq*(htim->Instance->PSC+1))-1;	
	if (period > 0xffff)
		period = 0xffff;
	
	htim->Instance->ARR = period;
	if (duty<-max_duty)
		duty = -max_duty;
	else if (duty > max_duty)
		duty = max_duty;

 
	duty = (htim->Instance->ARR+1)*duty/max_duty;
	switch(Channel){
		case 1:	
			htim->Instance->CCR1 = (uint32_t)duty;
		break;
		case 2:
			htim->Instance->CCR2 = (uint32_t)duty;
		break;
		case 3:
			htim->Instance->CCR3 = (uint32_t)duty;
		break;
		case 4:
			htim->Instance->CCR4 = (uint32_t)duty;
		break;
		default:
		break;
	}
}

void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) // interupt when enough pulse for each move
{
	cnt++;

	if(cnt == pulse_width[0])
	{
			PWM_out(PWMfreq,stop_duty,&htim4,1,&pulse_width[0]);
		//cnt =0;
	}
	else if(cnt == pulse_width[1])
	{
			PWM_out(PWMfreq,stop_duty,&htim4,2,&pulse_width[1]);
			cnt = 0;
	}
	else if(cnt == pulse_width[2])
	{
			PWM_out(PWMfreq,stop_duty,&htim4,3,&pulse_width[2]);
	}
	else if(cnt == pulse_width[3])
	{
			PWM_out(PWMfreq,stop_duty,&htim4,4,&pulse_width[3]);
	}
	else if(cnt == pulse_width[4])
	{
			//PWM_out(PWMfreq,stop_duty,&htim4,1,&pulse_width[4]);
	}
	else if(cnt == pulse_width[5])
	{
			//PWM_out(PWMfreq,stop_duty,&htim4,1,&pulse_width[1]);
	}
	
	/// reset pulse count
	
}

void ControlServo()
{
	PWM_out(PWMfreq,duty_default,&htim4,1,&pulse_width[0]);
	PWM_out(PWMfreq,duty_default,&htim4,2,&pulse_width[1]);
	PWM_out(PWMfreq,duty_default,&htim4,3,&pulse_width[2]);
	PWM_out(PWMfreq,duty_default,&htim4,4,&pulse_width[3]);
	//PWM_out(PWMfreq,duty_default,&htim4,5,&pulse_width[0]);
	//PWM_out(PWMfreq,duty_default,&htim4,6,&pulse_width[0]);
}
